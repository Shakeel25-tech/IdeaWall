<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Whiteboard</title>
  <style>
    /* Theme variables */
    :root {
      /* Dark (default) */
      --bg: #0f172a; /* slate-900 */
      --panel: #111827; /* gray-900 */
      --panel-top: #0b1220; /* top gradient tint for header */
      --panel-border: #1f2937; /* gray-800 */
      --text: #e5e7eb; /* gray-200 */
      --muted: #9ca3af; /* gray-400 */
      --accent: #22c55e; /* green-500 */
      --accent-2: #3b82f6; /* blue-500 */
      --danger: #ef4444; /* red-500 */
      --btn: #1f2937; /* gray-800 */
      --btn-hover: #374151; /* gray-700 */
      --board-bg: #0b1220; /* canvas wrapper bg */
      --glass-bg: rgba(17,24,39,0.7); /* statusbar background */
      --grid-glow: rgba(255,255,255,0.03);
    }

    :root[data-theme="light"] {
      --bg: #f8fafc; /* slate-50 */
      --panel: #ffffff;
      --panel-top: #f3f4f6; /* gray-100 */
      --panel-border: #e5e7eb; /* gray-200 */
      --text: #0f172a; /* slate-900 */
      --muted: #475569; /* slate-600 */
      --accent: #16a34a; /* green-600 */
      --accent-2: #2563eb; /* blue-600 */
      --danger: #dc2626; /* red-600 */
      --btn: #f1f5f9; /* slate-100 */
      --btn-hover: #e2e8f0; /* slate-200 */
      --board-bg: #f8fafc; /* match page bg */
      --glass-bg: rgba(255,255,255,0.7);
      --grid-glow: rgba(0,0,0,0.06);
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      overflow: hidden;
    }

    .app {
      display: grid;
      grid-template-rows: auto 1fr;
      height: 100vh;
      width: 100vw;
    }

    header.toolbar {
      display: flex;
      gap: 10px;
      align-items: center;
      padding: 10px;
      background: linear-gradient(0deg, var(--panel), var(--panel-top));
      border-bottom: 1px solid var(--panel-border);
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 700;
      letter-spacing: 0.3px;
      margin-right: 10px;
    }
    .brand .dot { height: 10px; width: 10px; border-radius: 999px; background: var(--accent-2); box-shadow: 0 0 10px var(--accent-2); }

    .group { display: inline-flex; gap: 6px; align-items: center; }
    .divider { width: 1px; height: 26px; background: var(--panel-border); margin: 0 6px; }

    button, .btn {
      appearance: none; border: 1px solid var(--panel-border);
      background: var(--btn);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 8px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 14px;
    }
    button:hover { background: var(--btn-hover); }
    button.active { outline: 2px solid var(--accent-2); outline-offset: 0; }
    button.danger { border-color: #3a0d0d; color: #fecaca; }
    button.danger:hover { background: #3a0d0d; }

    input[type="color"] {
      appearance: none; border: 1px solid var(--panel-border);
      width: 36px; height: 36px; padding: 0;
      border-radius: 6px; background: transparent; cursor: pointer;
    }
    input[type="range"] { cursor: pointer; }
    .label { color: var(--muted); font-size: 12px; }

    .board {
      position: relative;
      isolation: isolate;
      background: var(--board-bg);
    }

    /* Grid background overlay using CSS gradients */
    .board.grid::before {
      content: "";
      position: absolute; inset: 0; z-index: 0; pointer-events: none;
      background-image:
        linear-gradient(var(--panel-border) 1px, transparent 1px),
        linear-gradient(90deg, var(--panel-border) 1px, transparent 1px),
        radial-gradient(circle at 0 0, var(--grid-glow), transparent 120px);
      background-size: 24px 24px, 24px 24px, auto;
      background-position: 0 0, 0 0, 0 0;
      opacity: 0.4;
    }

    canvas#board { position: absolute; inset: 0; width: 100%; height: 100%; z-index: 1; touch-action: none; }

    .statusbar {
      position: absolute; right: 10px; bottom: 10px; z-index: 2;
      background: var(--glass-bg);
      border: 1px solid var(--panel-border);
      border-radius: 8px; padding: 6px 10px; font-size: 12px; color: var(--muted);
      display: flex; gap: 10px; align-items: center;
      backdrop-filter: blur(4px);
    }
    .kbd { border: 1px solid var(--panel-border); padding: 2px 6px; border-radius: 6px; color: #d1d5db; }

    @media (max-width: 720px) {
      .hide-sm { display: none; }
      header.toolbar { flex-wrap: wrap; row-gap: 8px; }
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="toolbar" role="toolbar" aria-label="Whiteboard toolbar">
      <div class="brand" title="Whiteboard">
        <div class="dot"></div>
        <span>Whiteboard</span>
      </div>

      <div class="group" role="group" aria-label="Tools">
        <button id="tool-pen" class="active" title="Pen (P)">üñäÔ∏è Pen</button>
        <button id="tool-eraser" title="Eraser (E)">üßΩ Eraser</button>
      </div>

      <div class="group" role="group" aria-label="Color and size">
        <span class="label hide-sm">Color</span>
        <input id="color" type="color" value="#22c55e" aria-label="Brush color" />
        <span class="label hide-sm">Size</span>
        <input id="size" type="range" min="1" max="60" value="6" aria-label="Brush size" />
        <span id="sizeValue" class="label">6 px</span>
      </div>

      <span class="divider"></span>

      <div class="group" role="group" aria-label="Editing">
        <button id="undo" title="Undo (Ctrl+Z)">‚Ü∂ Undo</button>
        <button id="redo" title="Redo (Ctrl+Y)">‚Ü∑ Redo</button>
        <button id="clear" class="danger" title="Clear board">üóëÔ∏è Clear</button>
      </div>

      <span class="divider"></span>

      <div class="group" role="group" aria-label="Export and view">
        <button id="download" title="Download PNG (Ctrl+S)">‚¨áÔ∏è Download</button>
        <label title="Toggle grid background" style="display:inline-flex; align-items:center; gap:6px; cursor:pointer">
          <input id="toggleGrid" type="checkbox" checked /> Grid
        </label>
        <button id="themeToggle" title="Toggle theme (T)">üåô Dark</button>
      </div>
    </header>

    <div id="boardWrap" class="board grid">
      <canvas id="board"></canvas>
      <div class="statusbar" aria-live="polite">
        <span id="statusTool">Tool: Pen</span>
        <span>‚Ä¢</span>
        <span id="statusSize">Size: 6</span>
        <span class="hide-sm">‚Ä¢</span>
        <span class="hide-sm">Shortcuts: <span class="kbd">P</span> <span class="kbd">E</span> <span class="kbd">Ctrl+Z</span> <span class="kbd">Ctrl+Y</span> <span class="kbd">Ctrl+S</span> <span class="kbd">T</span></span>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('board');
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      const boardWrap = document.getElementById('boardWrap');

      const toolPenBtn = document.getElementById('tool-pen');
      const toolEraserBtn = document.getElementById('tool-eraser');
      const colorInput = document.getElementById('color');
      const sizeInput = document.getElementById('size');
      const sizeValue = document.getElementById('sizeValue');
      const undoBtn = document.getElementById('undo');
      const redoBtn = document.getElementById('redo');
      const clearBtn = document.getElementById('clear');
      const downloadBtn = document.getElementById('download');
      const toggleGrid = document.getElementById('toggleGrid');
      const themeToggle = document.getElementById('themeToggle');

      const statusTool = document.getElementById('statusTool');
      const statusSize = document.getElementById('statusSize');

      const state = {
        tool: 'pen',
        color: colorInput.value,
        size: Number(sizeInput.value),
        penSize: Number(sizeInput.value),
        eraserSize: Number(sizeInput.value),
        drawing: false,
        last: null,
        history: [],
        redoStack: [],
        maxHistory: 40,
        dpr: Math.max(1, window.devicePixelRatio || 1),
        themeSaved: null,
      };

      // Theme logic
      function applyTheme(theme, persist = true) {
        document.documentElement.setAttribute('data-theme', theme);
        themeToggle.textContent = theme === 'dark' ? 'üåô Dark' : '‚òÄÔ∏è Light';
        themeToggle.setAttribute('aria-pressed', theme === 'dark' ? 'true' : 'false');
        if (persist) localStorage.setItem('wb-theme', theme);
      }

      function initTheme() {
        const saved = localStorage.getItem('wb-theme');
        state.themeSaved = saved;
        const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
        const theme = saved || (prefersDark ? 'dark' : 'light');
        applyTheme(theme, Boolean(saved));

        // If user hasn't chosen, follow system changes
        if (!saved && window.matchMedia) {
          const mq = window.matchMedia('(prefers-color-scheme: dark)');
          mq.addEventListener('change', (e) => {
            if (!localStorage.getItem('wb-theme')) {
              applyTheme(e.matches ? 'dark' : 'light', false);
            }
          });
        }
      }

      function toggleTheme() {
        const current = document.documentElement.getAttribute('data-theme') || 'dark';
        const next = current === 'dark' ? 'light' : 'dark';
        applyTheme(next, true);
      }

      function setActiveTool(tool) {
        state.tool = tool;
        toolPenBtn.classList.toggle('active', tool === 'pen');
        toolEraserBtn.classList.toggle('active', tool === 'eraser');
        statusTool.textContent = 'Tool: ' + (tool === 'pen' ? 'Pen' : 'Eraser');
        ctx.globalCompositeOperation = (tool === 'eraser') ? 'destination-out' : 'source-over';
        // Sync size slider and brush to the active tool's saved size
        const sizeForTool = tool === 'eraser' ? state.eraserSize : state.penSize;
        sizeInput.value = String(sizeForTool);
        setBrush({ size: sizeForTool });
      }

      function setBrush({ color = state.color, size } = {}) {
        // Determine effective size: explicit param or per-tool saved size
        const effectiveSize = (size != null) ? size : (state.tool === 'eraser' ? state.eraserSize : state.penSize);
        state.color = color;
        state.size = effectiveSize;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.strokeStyle = state.color;
        ctx.lineWidth = state.size * state.dpr;
        sizeValue.textContent = effectiveSize + ' px';
        statusSize.textContent = 'Size: ' + effectiveSize;
      }

      // Resize canvas to fill container, preserving content
      function resizeCanvas(preserve = true) {
        const rect = boardWrap.getBoundingClientRect();
        const { dpr } = state;

        let prev = null;
        if (preserve) {
          prev = document.createElement('canvas');
          prev.width = canvas.width;
          prev.height = canvas.height;
          prev.getContext('2d').drawImage(canvas, 0, 0);
        }

        canvas.width = Math.max(1, Math.floor(rect.width * dpr));
        canvas.height = Math.max(1, Math.floor(rect.height * dpr));

        canvas.style.width = rect.width + 'px';
        canvas.style.height = rect.height + 'px';

        ctx.setTransform(1, 0, 0, 1, 0, 0);
        // Keep a crisp scale for HiDPI
        ctx.scale(1, 1);

        setBrush();

        if (preserve && prev) {
          // Draw previous content scaled to new size
          ctx.drawImage(prev, 0, 0, prev.width, prev.height, 0, 0, canvas.width, canvas.height);
        } else {
          // Fill background transparent; grid is CSS overlay
          // Optionally could fill with white if desired
        }
      }

      function screenToCanvas(x, y) {
        const rect = canvas.getBoundingClientRect();
        const px = (x - rect.left) * state.dpr;
        const py = (y - rect.top) * state.dpr;
        return { x: px, y: py };
      }

      function startStroke(x, y) {
        state.drawing = true;
        state.last = screenToCanvas(x, y);
        ctx.beginPath();
        ctx.moveTo(state.last.x, state.last.y);
      }

      function moveStroke(x, y) {
        if (!state.drawing) return;
        const p = screenToCanvas(x, y);
        ctx.lineTo(p.x, p.y);
        ctx.stroke();
        state.last = p;
      }

      function endStroke() {
        if (!state.drawing) return;
        state.drawing = false;
        ctx.closePath();
        pushHistory();
      }

      function pushHistory() {
        // Save PNG data URL to keep memory reasonable and allow fast restore
        try {
          const dataUrl = canvas.toDataURL('image/png');
          state.history.push(dataUrl);
          if (state.history.length > state.maxHistory) state.history.shift();
          state.redoStack.length = 0; // clear redo on new action
          updateUndoRedoUI();
        } catch (e) {
          console.warn('History snapshot failed', e);
        }
      }

      function restoreFrom(dataUrl) {
        return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.globalCompositeOperation = 'source-over';
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            ctx.globalCompositeOperation = (state.tool === 'eraser') ? 'destination-out' : 'source-over';
            resolve();
          };
          img.src = dataUrl;
        });
      }

      async function undo() {
        if (state.history.length === 0) return;
        const current = canvas.toDataURL('image/png');
        state.redoStack.push(current);
        const last = state.history.pop();
        const prev = state.history[state.history.length - 1];
        if (prev) await restoreFrom(prev);
        else { ctx.clearRect(0, 0, canvas.width, canvas.height); }
        updateUndoRedoUI();
      }

      async function redo() {
        if (state.redoStack.length === 0) return;
        const next = state.redoStack.pop();
        await restoreFrom(next);
        state.history.push(next);
        updateUndoRedoUI();
      }

      function updateUndoRedoUI() {
        undoBtn.disabled = state.history.length <= 1; // at least one previous state
        redoBtn.disabled = state.redoStack.length === 0;
      }

      function clearBoard() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        pushHistory();
      }

      function downloadPNG() {
        // Compose onto a white background so eraser areas aren't transparent if user prefers white
        const out = document.createElement('canvas');
        out.width = canvas.width; out.height = canvas.height;
        const octx = out.getContext('2d');
        // White background
        octx.fillStyle = '#ffffff';
        octx.fillRect(0, 0, out.width, out.height);
        // Draw content
        octx.drawImage(canvas, 0, 0);
        const link = document.createElement('a');
        link.download = 'whiteboard.png';
        link.href = out.toDataURL('image/png');
        link.click();
      }

      // Pointer events
      canvas.addEventListener('pointerdown', (e) => {
        canvas.setPointerCapture(e.pointerId);
        setBrush();
        startStroke(e.clientX, e.clientY);
      });

      canvas.addEventListener('pointermove', (e) => {
        if (!state.drawing) return;
        moveStroke(e.clientX, e.clientY);
      });

      const endAny = () => endStroke();
      canvas.addEventListener('pointerup', endAny);
      canvas.addEventListener('pointercancel', endAny);
      canvas.addEventListener('pointerleave', () => { if (state.drawing) endStroke(); });

      // Tool buttons
      toolPenBtn.addEventListener('click', () => setActiveTool('pen'));
      toolEraserBtn.addEventListener('click', () => setActiveTool('eraser'));

      // Inputs
      colorInput.addEventListener('input', () => { setBrush({ color: colorInput.value }); });
      sizeInput.addEventListener('input', () => {
        const newSize = Number(sizeInput.value);
        if (state.tool === 'eraser') {
          state.eraserSize = newSize;
        } else {
          state.penSize = newSize;
        }
        setBrush({ size: newSize });
      });

      // Actions
      undoBtn.addEventListener('click', undo);
      redoBtn.addEventListener('click', redo);
      clearBtn.addEventListener('click', () => {
        if (confirm('Clear the board? This cannot be undone.')) clearBoard();
      });
      downloadBtn.addEventListener('click', downloadPNG);

      // Grid toggle
      toggleGrid.addEventListener('change', () => {
        boardWrap.classList.toggle('grid', toggleGrid.checked);
      });

      // Theme toggle
      themeToggle.addEventListener('click', toggleTheme);

      // Keyboard shortcuts
      window.addEventListener('keydown', (e) => {
        const ctrl = e.ctrlKey || e.metaKey;
        if (ctrl && e.key.toLowerCase() === 'z') { e.preventDefault(); undo(); }
        if (ctrl && e.key.toLowerCase() === 'y') { e.preventDefault(); redo(); }
        if (ctrl && e.key.toLowerCase() === 's') { e.preventDefault(); downloadPNG(); }
        if (!ctrl && (e.key === 'e' || e.key === 'E')) { setActiveTool('eraser'); }
        if (!ctrl && (e.key === 'p' || e.key === 'P')) { setActiveTool('pen'); }
        if (!ctrl && (e.key === 't' || e.key === 'T')) { toggleTheme(); }
        if (e.key === '[') { sizeInput.value = Math.max(1, Number(sizeInput.value) - 1); sizeInput.dispatchEvent(new Event('input')); }
        if (e.key === ']') { sizeInput.value = Math.min(60, Number(sizeInput.value) + 1); sizeInput.dispatchEvent(new Event('input')); }
      });

      // Handle resizing
      const resizeObserver = new ResizeObserver(() => resizeCanvas(true));
      resizeObserver.observe(boardWrap);

      // Initialize
      initTheme();
      resizeCanvas(false);
      setActiveTool('pen');
      setBrush();
      pushHistory(); // initial state
      updateUndoRedoUI();
    })();
  </script>
</body>
</html>